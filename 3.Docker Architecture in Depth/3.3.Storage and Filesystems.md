# Saqlash tizimi va Fayl tizimlari (Storage and Filesystems)

Salom va xush kelibsiz! Ushbu darsda biz **Docker**â€™ning **storage architecture** (saqlash arxitekturasi) va **file system** (fayl tizimlari) haqida texnik jihatdan chuqurroq tushunchaga ega boâ€˜lamiz.  
Mening ismim **Mumshad Mannambeth**, va bu dars davomida biz **Docker** qanday qilib **host**dagi maâ€™lumotlarni boshqarishini va **container file system**ning murakkabliklarini oâ€˜rganamiz.  
Biz **Docker** tomonidan yaratiladigan **folder structure**, **layered image architecture**, **copy-on-write mechanism**, va turli **storage drivers**ni tahlil qilamiz.

---

## Docker fayl tuzilmasi (Folder Structure)

Docker oâ€˜rnatilganda, u **/var/lib/docker** manzilida fayl tuzilmasini yaratadi.  
Ushbu katalog ichida bir nechta **subdirectories** (ichki papkalar) mavjud:  
`aufs`, `containers`, `images`, va `volumes`.

Bu kataloglar juda muhim, chunki ular barcha **Docker** bilan bogâ€˜liq maâ€™lumotlarni saqlaydi â€” yaâ€™ni **images**, **running containers**, va **persistent volumes** uchun fayllarni oâ€˜z ichiga oladi.  

Masalan:
- **containers** bilan bogâ€˜liq fayllar `containers` papkasida joylashgan;  
- **image** fayllari esa `images` papkasida saqlanadi.

---
### ðŸ“ Misol:
`/var/lib/docker/`

Har bir katalog Dockerâ€™ning maâ€™lum bir komponentiga xizmat qiladi:
- `containers/` â€” ishlayotgan yoki toâ€˜xtatilgan **container**lar haqidagi maâ€™lumotlar
- `images/` â€” **Docker image** fayllari
- `volumes/` â€” **persistent storage** uchun yaratilgan **Docker volumes**
- `aufs/` yoki boshqa **storage driver** kataloglari â€” **copy-on-write** qatlam tizimi uchun maâ€™lumotlar
---
Shunday qilib, **Docker**â€™ning barcha asosiy maâ€™lumotlari **/var/lib/docker** ichida saqlanadi.  
Bu katalogni tushunish â€” **troubleshooting**, **backup**, yoki **migration** jarayonlari uchun juda muhimdir.

# Docker Image Layered Architecture

**Docker images** â€” bu **layered architecture** (qatlamli arxitektura) asosida ishlaydi.  
**Dockerfile** ichidagi har bir **instruction** yangi **layer** (qatlam) yaratadi, u faqat oldingi qatlamdan farq qiluvchi oâ€˜zgarishlarni oâ€˜z ichiga oladi.

---

## Misol (Example Dockerfile):

```dockerfile
FROM Ubuntu

RUN apt-get update && apt-get -y install python
RUN pip install flask flask-mysql
COPY . /opt/source-code
ENTRYPOINT FLASK_APP=/opt/source-code/app.py flask run
```

Ushbu imageâ€™ni quyidagi buyruq yordamida build qilamiz:
```bash
docker build -t mmumshad/my-custom-app .
```

Ushbu build jarayonida:
- Asosiy **Ubuntu image** (~120 MB) yaratiladi.  
- Keyingi qatlamda **APT packages** (taxminan 300 MB) oâ€˜rnatiladi.  
- Qoâ€˜shimcha qatlamlar orqali **Python dependencies** qoâ€˜shiladi.  
- Ilovaning **source code** qismi **container**ga kiritiladi (injected).  
- Va nihoyat, **entry point** sozlanadi.

**Docker** ushbu qatlamlarni **cache** qilib saqlagani sababli, oâ€˜xshash **Dockerfile** â€” hatto faqat **source code** yoki **entry point** qismida farq qilsa ham â€” avvalgi **base image**, **package installation**, va **dependencies** qatlamlarini qayta ishlatishi (reuse) mumkin.

Masalan, boshqa bir **Dockerfile** quyidagicha koâ€˜rinishda boâ€˜lishi mumkin:
```dockerfile
FROM Ubuntu

RUN apt-get update && apt-get -y install python
RUN pip install flask flask-mysql
COPY app2.py /opt/source-code
ENTRYPOINT FLASK_APP=/opt/source-code/app2.py flask run
```

Ushbu ikkinchi imageâ€™ni quyidagi buyruq yordamida build qilamiz:
```bash
docker build -t mmumshad/my-custom-app-2 .
```

**Docker** birinchi uchta **layer**ni qayta ishlatadi (**reuses**) va faqat yangi **source code** va **entry point** oâ€˜z ichiga olgan **layers**ni qaytadan quradi.  
Bu samarali **caching mechanism** qurilish jarayonini (**build process**) tezlashtiradi va disk maydonini tejaydi.

---

### Layered Structure (pastdan yuqoriga qarab):

1. **Base Ubuntu image**  
2. **Installed packages**  
3. **Python dependencies**  
4. **Application source code**  
5. **Entry point configuration**

---

Bu tuzilma **Docker image**larning modulga asoslangan va samarali ishlashini taâ€™minlaydi.  
Agar dasturda faqat **source code** oâ€˜zgartirilsa, **Docker** faqat yuqori **layer**larni qayta quradi â€” bu esa vaqt va resurslarni tejashga yordam beradi.

**Build** yakunlangandan soâ€˜ng, yaratilgan **image layers** (qatlamlar) faqat **read-only** holatda boâ€˜ladi.  
Agar siz `docker run` buyrugâ€˜i yordamida yangi **container** ishga tushirsangiz, **Docker** ushbu **image layers** ustiga yangi **writable layer** (yoziladigan qatlam) ni **mount** qiladi.

Bu **writable layer** konteyner ishlash jarayonida (yaâ€™ni **runtime**) kiritilgan barcha oâ€˜zgarishlarni boshqaradi â€” masalan:
- **log files** (jurnal fayllari),
- **temporary files** (vaqtinchalik fayllar),
- yoki foydalanuvchi tomonidan kiritilgan oâ€˜zgarishlar (**user modifications**).

Misol uchun, agar siz **container** ichiga kirib, yangi fayl (`temp.txt`) yaratsangiz, ushbu fayl **writable layer** ichida saqlanadi.
```bash
docker run -it mmumshad/my-custom-app bash
# Inside the container:
touch temp.txt
```

Garchi **image layers** (image qatlamlari) oâ€˜zgarmas (**immutable**) boâ€˜lsa-da, **Docker** oâ€˜zgarishlarni amalga oshirish uchun **copy-on-write (CoW)** mexanizmidan foydalanadi.  
Ushbu jarayonda, agar siz **image layer** ichidagi faylni (masalan, `app.py`) oâ€˜zgartirmoqchi boâ€˜lsangiz, **Docker** avval bu faylni **writable layer** (yoziladigan qatlam)ga nusxalaydi, soâ€˜ngra siz kiritgan oâ€˜zgarishlarni qoâ€˜llaydi.  

Bu usul asl **image**â€™ni oâ€˜zgarmas holda saqlaydi, lekin har bir **container**â€™ga oâ€˜zining oâ€˜zgarishlarini saqlab qolish imkonini beradi.

>Agar biror **container** oâ€˜chirib tashlansa, u bilan birga uning **writable layer**â€™i va unda amalga oshirilgan barcha oâ€˜zgarishlar ham oâ€˜chiriladi.  
Muhim maâ€™lumotlarni (masalan, **database files**) saqlab qolish uchun, **external volume**â€™dan foydalanish kerak.

# Ma'lumotlarni saqlash (Persisting Data) â€” Volumes va Bind Mounts yordamida

Ma'lumotlarni saqlab qolish **stateful applications** uchun juda muhimdir. **Volume** yaratish uchun:
```bash
docker volume create data_volume
```

Ushbu buyruq `/var/lib/docker/volumes` ostida **volume directory** yaratadi.  
Soâ€˜ngra, **volume**ni maâ€™lum bir katalogga **mount** qilgan holda **container**ni ishga tushiring:
```bash
docker run -v data_volume:/var/lib/mysql mysql
```

Ushbu misolda, **MySQL** maâ€™lumotlarni **data_volume** ichiga yozadi, bu esa **container** oâ€˜chirib tashlansa ham maâ€™lumotlarning **data persistence** (doimiy saqlanishini) taâ€™minlaydi.  
Agar **volume** mavjud boâ€˜lmasa, **Docker** uni avtomatik tarzda yaratadi va siz buni **/var/lib/docker/volumes** tarkibini koâ€˜rish orqali tekshirishingiz mumkin.

Agar siz Docker hostâ€™da mavjud boâ€˜lgan katalogdan foydalanishni afzal koâ€˜rsangiz (masalan, /data/mysql), unda **bind mount** dan foydalaning:

```bash
docker run -v /data/mysql:/var/lib/mysql mysql
```
Bu buyruq **host directory**ni toâ€˜gâ€˜ridan-toâ€˜gâ€˜ri **container**ga bogâ€˜laydi.

> Garchi `-v` flag keng qoâ€˜llanilsa ham, yangiroq `--mount` opsiyasi oâ€˜zining aniq (explicit) sintaksisi tufayli afzal hisoblanadi. Masalan:
>```bash
>docker run --mount type=bind,source=/data/mysql,target=/var/lib/mysql mysql
>```

# Docker Storage Drivers (Docker saqlash drayverlari)

**Layered architecture**, **writable container layers**, va **copy-on-write** funksiyalari â€” bularning barchasi **Docker storage drivers** tomonidan taâ€™minlanadi.  
Quyida eng mashhur **storage driver** turlari keltirilgan:

| Storage Driver | Tavsif | Odatda ishlatiladigan holat |
|-----------------|--------|-----------------------------|
| **AUFS** | Advanced multi-layer union filesystem | Ubuntuâ€™da default sifatida |
| **BTRFS** | Modern Copy-on-Write filesystem | Kengaytirilgan ishlatish ssenariylari uchun |
| **VFS** | Simple filesystem used for debugging | Maxsus holatlar bilan cheklangan |
| **Device Mapper** | Uses Linux's device-mapper | Fedora/CentOS tizimlarida default |
| **Overlay/Overlay2** | Efficient copy-on-write drivers | Zamonaviy Linux distributsiyalarida ishlatiladi |

---

**Storage driver** tanlovi sizning **host operating system** va **performance requirements**â€™ga bogâ€˜liq.  
Masalan, **Ubuntu** odatda **AUFS**â€™dan foydalanadi,  
holbuki **Fedora** yoki **CentOS** esa **Device Mapper**â€™ni afzal koâ€˜radi.  

**Docker** tizimingiz uchun eng optimal **driver**â€™ni avtomatik tanlaydi,  
ammo zarur boâ€˜lsa siz uni qoâ€˜lda sozlashingiz (configure) ham mumkin.

---
Bu bilan bizning **Docker**â€™ning **storage** va **file system architecture** boâ€˜yicha oâ€˜rganishimiz yakuniga yetdi.  
Ushbu **storage drivers** va qoâ€˜shimcha **Docker concepts** haqida batafsil maâ€™lumot olish uchun **official Docker Documentation**â€™ga murojaat qiling.
