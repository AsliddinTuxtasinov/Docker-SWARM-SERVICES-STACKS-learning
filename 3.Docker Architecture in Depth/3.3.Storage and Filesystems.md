# Saqlash tizimi va Fayl tizimlari (Storage and Filesystems)

Salom va xush kelibsiz! Ushbu darsda biz **Docker**’ning **storage architecture** (saqlash arxitekturasi) va **file system** (fayl tizimlari) haqida texnik jihatdan chuqurroq tushunchaga ega bo‘lamiz.  
Mening ismim **Mumshad Mannambeth**, va bu dars davomida biz **Docker** qanday qilib **host**dagi ma’lumotlarni boshqarishini va **container file system**ning murakkabliklarini o‘rganamiz.  
Biz **Docker** tomonidan yaratiladigan **folder structure**, **layered image architecture**, **copy-on-write mechanism**, va turli **storage drivers**ni tahlil qilamiz.

---

## Docker fayl tuzilmasi (Folder Structure)

Docker o‘rnatilganda, u **/var/lib/docker** manzilida fayl tuzilmasini yaratadi.  
Ushbu katalog ichida bir nechta **subdirectories** (ichki papkalar) mavjud:  
`aufs`, `containers`, `images`, va `volumes`.

Bu kataloglar juda muhim, chunki ular barcha **Docker** bilan bog‘liq ma’lumotlarni saqlaydi — ya’ni **images**, **running containers**, va **persistent volumes** uchun fayllarni o‘z ichiga oladi.  

Masalan:
- **containers** bilan bog‘liq fayllar `containers` papkasida joylashgan;  
- **image** fayllari esa `images` papkasida saqlanadi.

---
### 📁 Misol:
`/var/lib/docker/`

Har bir katalog Docker’ning ma’lum bir komponentiga xizmat qiladi:
- `containers/` — ishlayotgan yoki to‘xtatilgan **container**lar haqidagi ma’lumotlar
- `images/` — **Docker image** fayllari
- `volumes/` — **persistent storage** uchun yaratilgan **Docker volumes**
- `aufs/` yoki boshqa **storage driver** kataloglari — **copy-on-write** qatlam tizimi uchun ma’lumotlar
---
Shunday qilib, **Docker**’ning barcha asosiy ma’lumotlari **/var/lib/docker** ichida saqlanadi.  
Bu katalogni tushunish — **troubleshooting**, **backup**, yoki **migration** jarayonlari uchun juda muhimdir.

# Docker Image Layered Architecture

**Docker images** — bu **layered architecture** (qatlamli arxitektura) asosida ishlaydi.  
**Dockerfile** ichidagi har bir **instruction** yangi **layer** (qatlam) yaratadi, u faqat oldingi qatlamdan farq qiluvchi o‘zgarishlarni o‘z ichiga oladi.

---

## Misol (Example Dockerfile):

```dockerfile
FROM Ubuntu

RUN apt-get update && apt-get -y install python
RUN pip install flask flask-mysql
COPY . /opt/source-code
ENTRYPOINT FLASK_APP=/opt/source-code/app.py flask run
```

Ushbu image’ni quyidagi buyruq yordamida build qilamiz:
```bash
docker build -t mmumshad/my-custom-app .
```

Ushbu build jarayonida:
- Asosiy **Ubuntu image** (~120 MB) yaratiladi.  
- Keyingi qatlamda **APT packages** (taxminan 300 MB) o‘rnatiladi.  
- Qo‘shimcha qatlamlar orqali **Python dependencies** qo‘shiladi.  
- Ilovaning **source code** qismi **container**ga kiritiladi (injected).  
- Va nihoyat, **entry point** sozlanadi.

**Docker** ushbu qatlamlarni **cache** qilib saqlagani sababli, o‘xshash **Dockerfile** — hatto faqat **source code** yoki **entry point** qismida farq qilsa ham — avvalgi **base image**, **package installation**, va **dependencies** qatlamlarini qayta ishlatishi (reuse) mumkin.

Masalan, boshqa bir **Dockerfile** quyidagicha ko‘rinishda bo‘lishi mumkin:
```dockerfile
FROM Ubuntu

RUN apt-get update && apt-get -y install python
RUN pip install flask flask-mysql
COPY app2.py /opt/source-code
ENTRYPOINT FLASK_APP=/opt/source-code/app2.py flask run
```

Ushbu ikkinchi image’ni quyidagi buyruq yordamida build qilamiz:
```bash
docker build -t mmumshad/my-custom-app-2 .
```

**Docker** birinchi uchta **layer**ni qayta ishlatadi (**reuses**) va faqat yangi **source code** va **entry point** o‘z ichiga olgan **layers**ni qaytadan quradi.  
Bu samarali **caching mechanism** qurilish jarayonini (**build process**) tezlashtiradi va disk maydonini tejaydi.

---

### Layered Structure (pastdan yuqoriga qarab):

1. **Base Ubuntu image**  
2. **Installed packages**  
3. **Python dependencies**  
4. **Application source code**  
5. **Entry point configuration**

---

Bu tuzilma **Docker image**larning modulga asoslangan va samarali ishlashini ta’minlaydi.  
Agar dasturda faqat **source code** o‘zgartirilsa, **Docker** faqat yuqori **layer**larni qayta quradi — bu esa vaqt va resurslarni tejashga yordam beradi.

**Build** yakunlangandan so‘ng, yaratilgan **image layers** (qatlamlar) faqat **read-only** holatda bo‘ladi.  
Agar siz `docker run` buyrug‘i yordamida yangi **container** ishga tushirsangiz, **Docker** ushbu **image layers** ustiga yangi **writable layer** (yoziladigan qatlam) ni **mount** qiladi.

Bu **writable layer** konteyner ishlash jarayonida (ya’ni **runtime**) kiritilgan barcha o‘zgarishlarni boshqaradi — masalan:
- **log files** (jurnal fayllari),
- **temporary files** (vaqtinchalik fayllar),
- yoki foydalanuvchi tomonidan kiritilgan o‘zgarishlar (**user modifications**).

Misol uchun, agar siz **container** ichiga kirib, yangi fayl (`temp.txt`) yaratsangiz, ushbu fayl **writable layer** ichida saqlanadi.
```bash
docker run -it mmumshad/my-custom-app bash
# Inside the container:
touch temp.txt
```

Garchi **image layers** (image qatlamlari) o‘zgarmas (**immutable**) bo‘lsa-da, **Docker** o‘zgarishlarni amalga oshirish uchun **copy-on-write (CoW)** mexanizmidan foydalanadi.  
Ushbu jarayonda, agar siz **image layer** ichidagi faylni (masalan, `app.py`) o‘zgartirmoqchi bo‘lsangiz, **Docker** avval bu faylni **writable layer** (yoziladigan qatlam)ga nusxalaydi, so‘ngra siz kiritgan o‘zgarishlarni qo‘llaydi.  

Bu usul asl **image**’ni o‘zgarmas holda saqlaydi, lekin har bir **container**’ga o‘zining o‘zgarishlarini saqlab qolish imkonini beradi.

>Agar biror **container** o‘chirib tashlansa, u bilan birga uning **writable layer**’i va unda amalga oshirilgan barcha o‘zgarishlar ham o‘chiriladi.  
Muhim ma’lumotlarni (masalan, **database files**) saqlab qolish uchun, **external volume**’dan foydalanish kerak.

# Ma'lumotlarni saqlash (Persisting Data) — Volumes va Bind Mounts yordamida

Ma'lumotlarni saqlab qolish **stateful applications** uchun juda muhimdir. **Volume** yaratish uchun:
```bash
docker volume create data_volume
```

Ushbu buyruq `/var/lib/docker/volumes` ostida **volume directory** yaratadi.  
So‘ngra, **volume**ni ma’lum bir katalogga **mount** qilgan holda **container**ni ishga tushiring:
```bash
docker run -v data_volume:/var/lib/mysql mysql
```

Ushbu misolda, **MySQL** ma’lumotlarni **data_volume** ichiga yozadi, bu esa **container** o‘chirib tashlansa ham ma’lumotlarning **data persistence** (doimiy saqlanishini) ta’minlaydi.  
Agar **volume** mavjud bo‘lmasa, **Docker** uni avtomatik tarzda yaratadi va siz buni **/var/lib/docker/volumes** tarkibini ko‘rish orqali tekshirishingiz mumkin.

Agar siz Docker host’da mavjud bo‘lgan katalogdan foydalanishni afzal ko‘rsangiz (masalan, /data/mysql), unda **bind mount** dan foydalaning:

```bash
docker run -v /data/mysql:/var/lib/mysql mysql
```
Bu buyruq **host directory**ni to‘g‘ridan-to‘g‘ri **container**ga bog‘laydi.

> Garchi `-v` flag keng qo‘llanilsa ham, yangiroq `--mount` opsiyasi o‘zining aniq (explicit) sintaksisi tufayli afzal hisoblanadi. Masalan:
>```bash
>docker run --mount type=bind,source=/data/mysql,target=/var/lib/mysql mysql
>```

# Docker Storage Drivers (Docker saqlash drayverlari)

**Layered architecture**, **writable container layers**, va **copy-on-write** funksiyalari — bularning barchasi **Docker storage drivers** tomonidan ta’minlanadi.  
Quyida eng mashhur **storage driver** turlari keltirilgan:

| Storage Driver | Tavsif | Odatda ishlatiladigan holat |
|-----------------|--------|-----------------------------|
| **AUFS** | Advanced multi-layer union filesystem | Ubuntu’da default sifatida |
| **BTRFS** | Modern Copy-on-Write filesystem | Kengaytirilgan ishlatish ssenariylari uchun |
| **VFS** | Simple filesystem used for debugging | Maxsus holatlar bilan cheklangan |
| **Device Mapper** | Uses Linux's device-mapper | Fedora/CentOS tizimlarida default |
| **Overlay/Overlay2** | Efficient copy-on-write drivers | Zamonaviy Linux distributsiyalarida ishlatiladi |

---

**Storage driver** tanlovi sizning **host operating system** va **performance requirements**’ga bog‘liq.  
Masalan, **Ubuntu** odatda **AUFS**’dan foydalanadi,  
holbuki **Fedora** yoki **CentOS** esa **Device Mapper**’ni afzal ko‘radi.  

**Docker** tizimingiz uchun eng optimal **driver**’ni avtomatik tanlaydi,  
ammo zarur bo‘lsa siz uni qo‘lda sozlashingiz (configure) ham mumkin.

---
Bu bilan bizning **Docker**’ning **storage** va **file system architecture** bo‘yicha o‘rganishimiz yakuniga yetdi.  
Ushbu **storage drivers** va qo‘shimcha **Docker concepts** haqida batafsil ma’lumot olish uchun **official Docker Documentation**’ga murojaat qiling.
